
# Table of Contents

1.  [What even is an FPGA? How do they differ from microcontrollers. What actually changes during reconfiguration.](#orgbe8621f)
2.  [Question about + operator on wires](#org9bb7240)
3.  [Logic vs wire vs others - 2 state vs 4 state](#orgc2245ab)
4.  [blocking and nonblocking assignment](#org84a02db)
5.  [What does timescale do?](#org6e7808e)
6.  [Sites I bailed out to for help getting my Verilog testbench working-](#orgc347ca3)
7.  [TODO](#orgf152f82)
    1.  [#delays for S.V. testbenches](#orgb220f8c)
    2.  [Design vs testbench](#org6aae438)
    3.  [Initial states of nets](#org99d75ed)
    4.  [Signed vs unsigned](#orgc60b411)
    5.  [Icarus verilog, steps in compilation and simulation](#orgf5d6680)
    6.  [Gtkwave and tracing](#org1374705)
        1.  [dumpvars syntax, number of levels of hierarchy traced](#org69ccdce)



<a id="orgbe8621f"></a>

# What even is an FPGA? How do they differ from microcontrollers. What actually changes during reconfiguration.

-   [nandland - What is an FPGA](https://www.nandland.com/articles/what-is-an-fpga-what-is-an-asic.html)


<a id="org9bb7240"></a>

# Question about + operator on wires

&ldquo;All SystemVerilog arithmetic operators are synthesizable, but specific ASICs and FPGAs might have restrictions on what can be implemented at the gate-level in that device. Operations such as multiply, divide, modulus, and power are complex circuits in hardware, and can require a substantial amount of logic gates and propagation timing paths.&rdquo; - Sutherland pg 184


<a id="orgc2245ab"></a>

# Logic vs wire vs others - 2 state vs 4 state

&ldquo;3.1 Four-state data values
For RTL modeling, SystemVerilog uses a four-value representation of the values that can occur in silicon.
• 0 represents an abstract digital low, with no voltage or current associated with it.
• 1 represents an abstract digital high, with no voltage or current associated with it.
• Z represents an abstract digital high-impedance. In a multi-driver circuit, a value of 0 or 1 will override a Z. Some programming operators and programming statements treat Z values as don’t care values (see Chapter 5, section 5.9, page 171, and Chap­ ter 6 section 6.2.2, page 223).
• X represents either an uninitialized value, an uncertain value, or a conflict of values ina multi-driver circuit. It certain RTL model contexts, synthesis compilers treat an X value as a don’t-care value (see Chapter 9, section 9.3.6, page 345).
The values of 0, 1 and Z are an abstraction of values that can exist in actual silicon. The value of X is not an actual silicon values. Simulators use X to indicate a degree of uncertainty in how physical silicon would behave under specific circumstances, such as when simulation cannot predict whether an actual silicon value would be a 0 or 1 (or Z for a tri-state device). For synthesis, an X value also provides design engineers a way to specify “don’t-care” conditions, where the engineer is not concerned about whether actual silicon will have a 0 or a 1 value for a specific condition.&rdquo; Sutherland pages 61-62


<a id="org84a02db"></a>

# blocking and nonblocking assignment

[Sutherland Presentation on Blocking vs Nonblocking](https://sutherland-hdl.com/papers/1996-CUG-presentation_nonblocking_assigns.pdf)

&ldquo;SystemVerilog has two types of procedural assignments: blocking, represented with a single equal token ( = ) and nonblocking, represented with a less-than-equal token (<=)&#x2026;.  In brief, blocking assignments are used when modeling the behavior of combinational logic, such as digital logic gates, multiplex­ ors and decoders. Nonblocking assignments are used when modeling the behavior of sequential logic, such as flip-flops, registers, counters and pipelines. Using a blocking assignment, including any of these assignment operators, to assign a value to the output of a sequential logic block can result in simulation race conditions, which can lead to the RTL model behavior not matching the synthesized gate-level behavior&rdquo; Sutherland 196-197


<a id="org6e7808e"></a>

# What does timescale do?

&ldquo;Simulation requires representing the passing of time. The SystemVerilog standard allows time to be specified in units ranging anywhere from 1 femtosecond to 100 sec­ onds.
SystemVerilog also allows the time precision to be specified. Time precision con­ trols how many decimal places of accuracy simulation should use. Any delays in a module with a greater number of decimal places will be rounded off to the precision.
Precision is specified relative to the time units. If the time unit is 1 nanosecond, for example, a precision of 1 picosecond would allow for 3 decimal places of accuracy (a nanosecond is 10&rsquo; and a picosecond is 10 , yielding a difference of 10 , or 3 deci­ mal places).
The units of time and time precision used in a SystemVerilog module can be speci­ fied at the module level, using timeunit and timeprecision statements. For example:&rdquo;
\`\`\`
module adder
(input logic a, b, ci,
 output logic sum, co
 );
     timeunit 1ns;          */ delays are in nanoseconds
     timeprecision 1ps;     /* 2 decimal places of accuracy (relative to timeunit)
     &#x2026;
endmodule: adder
\`\`\`

Can also do

\`\`\`
timeunit 1ns/1ps;
\`\`\`

&ldquo;Traditional Verilog’s ‘timescale compiler directive. It is also possible to specify time units and time precision on a semi-global basis, using a &rsquo; timescale compiler directive. This directive must be specified outside of the module boundary, in the
$unit declaration space&rdquo; - Sutherland page 24

**Sutherland Best Practice Guideline**

&ldquo;Use the SystemVerilog timeunit keyword to specify simulation time units and precision, instead of the old &rsquo; timescale compiler directive.&rdquo;


<a id="orgc347ca3"></a>

# Sites I bailed out to for help getting my Verilog testbench working-

[Asic-World - Testbenches](http://www.asic-world.com/systemverilog/basic4.html#Test_Benches)
[Icarus verilog testbench and gtkwave](https://riptutorial.com/verilog/example/29033/using-icarus-verilog-and-gtkwaves-to-simulate-and-view-a-design-graphically )


<a id="orgf152f82"></a>

# TODO


<a id="orgb220f8c"></a>

## #delays for S.V. testbenches


<a id="org6aae438"></a>

## Design vs testbench


<a id="org99d75ed"></a>

## Initial states of nets


<a id="orgc60b411"></a>

## Signed vs unsigned


<a id="orgf5d6680"></a>

## Icarus verilog, steps in compilation and simulation


<a id="org1374705"></a>

## Gtkwave and tracing


<a id="org69ccdce"></a>

### dumpvars syntax, number of levels of hierarchy traced

