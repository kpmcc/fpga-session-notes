
# Table of Contents

1.  [What even is an FPGA? How do they differ from microcontrollers. What actually changes during reconfiguration.](#org78ac06c)
2.  [Question about + operator on wires](#orgbf325ab)
3.  [Logic vs wire vs others - 2 state vs 4 state](#org7704fd3)
4.  [blocking and nonblocking assignment](#orgf92b98d)
5.  [What does timescale do?](#orge16cb44)
6.  [Sites I bailed out to for help getting my Verilog testbench working](#org3595226)
7.  [TODO](#org9583a20)



<a id="org78ac06c"></a>

# What even is an FPGA? How do they differ from microcontrollers. What actually changes during reconfiguration.

-   [nandland - What is an FPGA](https://www.nandland.com/articles/what-is-an-fpga-what-is-an-asic.html)


<a id="orgbf325ab"></a>

# Question about + operator on wires

&ldquo;All SystemVerilog arithmetic operators are synthesizable, but specific ASICs and FPGAs might have restrictions on what can be implemented at the gate-level in that device. Operations such as multiply, divide, modulus, and power are complex circuits in hardware, and can require a substantial amount of logic gates and propagation timing paths.&rdquo; - Sutherland pg 184


<a id="org7704fd3"></a>

# Logic vs wire vs others - 2 state vs 4 state

Four-state data values
For RTL modeling, SystemVerilog uses a four-value representation of the values that can occur in silicon.

1.  0 represents an abstract digital low, with no voltage or current associated with it.
2.  1 represents an abstract digital high, with no voltage or current associated with it.
3.  Z represents an abstract digital high-impedance. In a multi-driver circuit, a value of 0 or 1 will override a Z. Some programming operators and programming statements treat Z values as don’t care values (see Chapter 5, section 5.9, page 171, and Chapter 6 section 6.2.2, page 223).
4.  X represents either an uninitialized value, an uncertain value, or a conflict of values ina multi-driver circuit. It certain RTL model contexts, synthesis compilers treat an X value as a don’t-care value (see Chapter 9, section 9.3.6, page 345).

The values of 0, 1 and Z are an abstraction of values that can exist in actual silicon. The value of X is not an actual silicon values. Simulators use X to indicate a degree of uncertainty in how physical silicon would behave under specific circumstances, such as when simulation cannot predict whether an actual silicon value would be a 0 or 1 (or Z for a tri-state device). For synthesis, an X value also provides design engineers a way to specify “don’t-care” conditions, where the engineer is not concerned about whether actual silicon will have a 0 or a 1 value for a specific condition. - Sutherland pages 61-62


<a id="orgf92b98d"></a>

# blocking and nonblocking assignment

-   [Sutherland Presentation on Blocking vs Nonblocking](https://sutherland-hdl.com/papers/1996-CUG-presentation_nonblocking_assigns.pdf)

-   Sutherland 196-197:
    
    SystemVerilog has two types of procedural assignments:
    
    1.  blocking, represented with a single equal token ( = )
    2.  nonblocking, represented with a less-than-equal token (<=)
    
    Blocking assignments are used when modeling the behavior of combinational logic, such as digital logic gates, multiplexors and decoders.
    
    Nonblocking assignments are used when modeling the behavior of sequential logic, such as flip-flops, registers, counters and pipelines.
    
    Using a blocking assignment, including any of these assignment operators, to assign a value to the output of a sequential logic block can result in simulation race conditions, which can lead to the RTL model behavior not matching the synthesized gate-level behavior


<a id="orge16cb44"></a>

# What does timescale do?

Simulation requires representing the passing of time. The SystemVerilog standard allows time to be specified in units ranging anywhere from 1 femtosecond to 100 seconds.
SystemVerilog also allows the time precision to be specified. Time precision controls how many decimal places of accuracy simulation should use. Any delays in a module with a greater number of decimal places will be rounded off to the precision. Precision is specified relative to the time units. If the time unit is 1 nanosecond, for example, a precision of 1 picosecond would allow for 3 decimal places of accuracy (a nanosecond is 10&rsquo; and a picosecond is 10 , yielding a difference of 10 , or 3 decimal places). The units of time and time precision used in a SystemVerilog module can be specified at the module level, using timeunit and timeprecision statements.

For example:

    module adder
    (input logic a, b, ci,
     output logic sum, co
     );
         timeunit 1ns;          // delays are in nanoseconds
         timeprecision 1ps;     // 2 decimal places of accuracy (relative to timeunit)
         ...
    endmodule: adder

One can also do

    timeunit 1ns/1ps;

Traditional Verilog’s \`timescale compiler directive. It is also possible to specify time units and time precision on a semi-global basis, using a \`timescale compiler directive. This directive must be specified outside of the module boundary, in the $unit declaration space - Sutherland page 24

**Sutherland Best Practice Guideline**

&ldquo;Use the SystemVerilog timeunit keyword to specify simulation time units and precision, instead of the old \`timescale compiler directive.&rdquo;


<a id="org3595226"></a>

# Sites I bailed out to for help getting my Verilog testbench working

-   [Asic-World - Testbenches](http://www.asic-world.com/systemverilog/basic4.html#Test_Benches)

[- Icarus verilog testbench and gtkwave](https://riptutorial.com/verilog/example/29033/using-icarus-verilog-and-gtkwaves-to-simulate-and-view-a-design-graphically )


<a id="org9583a20"></a>

# TODO

-   \#delays for S.V. testbenches
-   Design vs testbench
-   Initial states of nets
-   Signed vs unsigned
-   Icarus verilog, steps in compilation and simulation
-   Gtkwave and tracing
    -   dumpvars syntax, number of levels of hierarchy traced

